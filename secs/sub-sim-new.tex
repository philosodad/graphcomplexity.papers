
\label{sec:sim-new}

In this section, we create a new simulator to solve the Maximum Weighted Independent Set problem. It should be noted that as this is an example, we are not concerned about the quality of our algorithm as long as it produces an independent set. We will apply the dependency graph framework in our algorithm.

\paragraph{Problem Definition}
\input{defs/def-is.tex}

\paragraph{Approach}

We start by formulating an algorithm to solve the problem. In this case, we will use the Dependency Graph framework to solve the problem, passing over the question of whether this problem can be solved locally at all.

The steps for Algorithm~\ref{alg:alg-isdg} are as follows.

\begin{enumerate}
\item Each node builds all possible independent sets out to its two hop neighbors.
\item Each node ranks its independent sets, first on weight and then by shared nodes with other sets.
\item Use the sets to determine whether to turn on and off according to these rules:
\begin{enumerate}
\item If a node is in the heaviest local node in the best possible set, it turns on.
\item If a neighbor turns on, turn off.
\end{enumerate}
\item When all algorithms are decided, complete.
\end{enumerate}

In the end, we should end up with an independent set.

\paragraph{Classes}

To build this simulator we will need a minimum of~\ref{en:classlist-lastline} classes.
\begin{enumerate}
\item A Dependency Graph Node.
\item A Dependency Graph.
\item A Node.
\item A Graph.
\item A Simulator.\label{en:classlist-lastline}
\end{enumerate}

In this case, we will start in the middle and design the Node first. Looking at Figure~\ref{fig:node-class}, the {\bfseries BasicNode} has most of what we will need. We only need to add an attribute for building the Dependency Graph, and probably a method to do so. Looking through the types that we have, we realize that {\bfseries PCDRoot} (Figure~\ref{fig:pcd-node-class}) is actually an appropriate starting point for our new node type. It has an appropriate constructor and appropriate attributes, even though the variable {\em covers} and the method {\em init\_covers} have names that are less generic than we might like. We can write a new Node type that inherits this in just a few lines by overloading {\ttfamily get\_dep\_graph\_type}. Example~\ref{exa:isdg-1} shows the new class definition.

\input{exas/exa-isdg-1.tex}

In order to build a dependency graph, we need to be able to create the solutions. We've decided that each node should consider its two-hop neighborhood. From prior testing, we know that in order to generate sets, the most efficient method is probably going to be to use the {\bfseries Combinator} module, which can take a set of nodes and edges are returns sets of Node ids that represent covers. For this problem, we want to use the module to take a set of nodes and edges and return ids that represent independent sets. Looking at the code in Example~\ref{exa:combinator-1}, we can see the flow of control in the Combinator Module. 

\input{exas/exa-combinator-1.tex}

The method {\ttfamily construct\_covers} serves as the interface for the other methods. The only method that is specific to returning covers is the method {\ttfamily test\_cover?}, which takes an array of edges and a combination of Node ids and tests whether the combination is a cover. The {\bfseries \&} operator is the set intersection operator, so the line {\ttfamily e.each\{|k| return false if (c\&k).empty?\}} translates as ''return false if one of these edges contains an id that is not in 'c'". For independent set, we want a test that returns false if the id combination (c) contains {\em both} of the ids in any edge. To accomplish this, we could use the array difference operator, and return false if the subtraction of c from any edge results in an empty array. The modified module with the new definition of {\ttfamily test\_cover?} is shown in Example~\ref{exa:is-combinator}.  

\input{exas/exa-is-combinator.tex}

The new module must be included into the definition of {\bf ISDGRoot} in order to be used, resulting in the definition shown in Example~\ref{exa:isdg-2}. 

\input{exas/exa-isdg-2.tex}  

It makes sense at this time to design the Dependency Graph for Independent Set. The nodes of our dependency graph will be the sets that are built with our modified {\bfseries Combinator} module, and the edges will be determined by the relationships between those nodes. Our first step will be to define the dependency graph itself, with it's constructor, and then we will move on to defining the nodes. Before we design the Dependency Graph for Independent Set, it will be illustrative to look at the root class in Example~\ref{exa:dep-graph-root}.

\input{exas/exa-dep-graph-root.tex}

The {\ttfamily include} statements starting on line~\ref{code:dep-graph-includes} introduce a new module, {\bfseries Cleanable}. Cleanable contains the method {\ttfamily kill\_redundant} called on line~\ref{code:dep-graph-kill}. This method takes the input and deletes any proper subsets. This is useful in our case since every single node in the two-hop neighborhood will be considered an independent set; we would prefer to limit the number of sets to only those sets of maximum size. Figure~\ref{fig:is-graph-1} shows a graph and the independent sets that will be considered for a specific node after the redundant sets have been pruned. We should also notice the call in line~\ref{code:dep-graph-push-node} for the {\ttfamily get\_node\_type} method. This is a call that we will need to override for our own class definition. 

\input{figs/fig-is-graph-1.tex}


