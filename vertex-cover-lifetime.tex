\input{preamble.tex}
\begin{document}
\title{Distributed Vertex Cover and Network Lifetime Algorithms in Graphs} 

\author{\IEEEauthorblockN{J. Paul Daigle}
\IEEEauthorblockA{Department of Computer Science\\
Georgia State University\\
Atlanta, Georgia 30303\\
Email: jdaigle1@student.gsu.edu}
}

\maketitle

\begin{abstract}
  Target coverage in a sensor network can be easily modeled as a vertex covering problem. This paper explores the relationship between the Minimum Weighted Vertex Cover problem and the Network Lifetime problem. We present new algorithms for both MWVC and NL and test their performance against existing algorithms. We find that the algorithms that perform well for MWVC also perform well for NL.
\end{abstract}
\section{Introduction}
``Macroscopes'' composed of a network of wireless sensors are a valuable research tool in several science and security domains~\cite{1098925,990703}. Because such sensors have limited data processing capacities and limited battery life, it is important to use sensors efficiently. A common problem in sensor networks is the area coverage problem, which concerns the ability of the network to record data over an area or areas of interest. If the sensors are installed in some location where batteries can be replaced and the properties of the network are understood before deployment, this is not a difficult problem. However, sensor networks can also be randomly distributed in areas that are difficult to reach. In that case it is advantageous to have local, distributed algorithms to solve problems like area coverage.

Vertex Cover is a problem that is related to Target or Area coverage. Section~\ref{sec:area-vertex} presents a proof that the area coverage problem in a homogenous sensor network is equivalent to the vertex cover problem in the hypergraph. A graph is a special case of hypergraph, a 2-uniform hypergraph, so the argument extends to graphs. Section~\ref{sec:life-depend} presents a rationale for examining the Minimum Weighted Vertex Cover (MWVC) problem in relation to network lifetime. Other problems in biology, communication, and circuit design can also be formulated as instances of MWVC.

It has been shown that a constant approximation of MWVC cannot be found by a distributed algorithm in a constant number of rounds.\cite{1011811} We present a distributed two-approximate algorithm to solve MWVC in an expected running time of $O(logn)$, based on the sequential algorithm of Gonzalez.\cite{Gonzalez1995129} This is not the first such algorithm to appear in the literature, but there are implementation advantages to our approach.

Because of the relationship between Vertex Cover and Area Cover, we consider whether strategies that reduce the minimum weighted vertex cover can be used to increase network lifetime by considering weight as a measure of battery life. Accordingly, we introduce a new Algorithm for Weighted Vertex Cover with constant run time and consistent 2-approximate performance and compare its performance in extending network lifetime versus the one-hop algorithm of Prasad and Dhawan \cite{Dhawan:hipc-09}. 

All of the distributed algorithms described are assumed to be running on a message passing model, the compute nodes are mapped to the vertexes of the graph, and the edges of the graph represent viable paths for communication between nodes. 

\section{Prior Work}

\section{Coverage Problems}
The coverage problems in this paper are common coverage problems which are known to be NP-Complete. For convenience, the problem definitions are provided here.
\subsection{Problem Definitions}
\input{defs/vertex-cover-def.tex}
\input{defs/target-cover-def.tex}

\subsection{Area Cover as Vertex Cover}
\label{sec:area-vertex}
The area coverage problem in sensor networks has been shown to be equivalent to target coverage.\cite{IPDPS.2008.45361} This can be extended to the vertex cover problem in Hypergraphs. Intuitively, there is an obvious relationship between the collection of vertices that make up a given edge and the collection of sensors that cover a given target.  Theorem~\ref{thm:equiv} formally expresses this equivalency.

\input{proofs/target-vertex-proof.tex}

It follows from the proof that if a target cover is minimal for the sensor network, the equivalent cover in the hypergraph is minimal to that graph. Similarly, a MVC of the isomophic hypergraph is a minimum target cover for the sensor network. It also follows that target coverage is equivalent to vertex cover in a graph, because a graph is a 2-cardinal hypergraph.

\section{Algorithms}
\label{sec:algorithms}

\subsection{Maximal Matching Algorithm for Minimum Weighted Vertex Cover}
Algorithm~\ref{alg:dgmm} is our distributed implementation of the 2-approximate minimum weighted vertex cover algorithm presented by Gonzalez.\cite{Gonzalez1995129} The Gonzalez algorithm proceeds by selecting each edge in turn and choosing one of the endpoints of that edge to add to the cover. The sequential algorithm goes through each edge in turn, adding vertexes when necessary. Each edge, as examined, is assigned a weight according to equation~\ref{eqn:gmm}. If the weight of a vertex is equal to the sum of it's incident edge weights, that vertex is added to the cover. 

\input{eqns/eqn-gmm.tex}

The distributed version of the algorithm chooses some disjoint set of edges and performs exactly the same calculations. The precise method of choosing edges and updating weights is given in Algorithm~\ref{alg:dgmm}. The general progress of the algorithm is defined by the automata in Figure~\ref{fig:dgmm-auto}. Each node begins in the \cCd state, and chooses to either send invitations (\cId), or listen for invitation (\cLd). Nodes in the \cId state choose one neighbor to send an invitation to and wait for a response \cWd, and nodes in the \cLd state choose one invitation to accept, which is sent in the response state \cRd. All nodes that have formed a pair in this manner then update their status (\cUd) and (\cEd) exchange data with their neighbors. Nodes that have chosen to turn on or off move to the done state (\cDd).  

\input{figs/fig-dgmm.tex}

Vertex pairs are able to assign a weight to the edge between them independently, and therefore decide whether or not to join the cover. During the \cEd stage neighboring vertexes are able to update some of their own edge weights. 

\input{alg/alg-dgmm.tex}

\subsection{Proof of 2-Approximation}
\input{proofs/prf-dgmm2.tex}

\section{Dependency Graph}
\label{sec:life-depend}
Target Coverage and Minimum Weighted Vertex Cover are both NP-Complete problems. It has also been proved that MWVC cannot be approximated to a constant factor locally within any constant number of communication rounds~\cite{1011811}, and as we have shown this limitation must apply to target coverage as well. The Dependency Graph is a heuristic framework for such problems~\cite{IPDPS.2008.45361}. It has been shown to produce good results when applied to the Lifetime Maximization problem in sensor networks~\cite{978-3-540-89894-8_26}.

The framework applies to problems where local solutions can be combined to form a feasible global solution. The essential steps of the framework are: 
\begin{enumerate}
\item Establish that combined local solutions lead to a feasible global solution
\item Model the state space of the local solutions
\item Determine a priority heuristic for local solutions
\item Design a reasonable negotiating strategy between neighbors
\end{enumerate} 
A detailed description of each of these steps can be found in~\cite{IPDPS.2008.45361}.

The application of the framework relies on dependencies between local solutions. In the case of the MWVC problem, there are several approaches that can be taken to determine what a local solution is. The simplest approach is to have each vertex only consider edges incident to itself. Naively, each vertex would have exactly two local solutions, the cover containing itself and the cover containing all of its neighbors. This would be insufficient for allowing for any negotiation between neighbors, as shown in Figure~\ref{fig:negprob}. If each vertex can {\em only} choose either itself or all its neighbors, the feasible solutions give weights of 34 and 29, but the optimal solution for that graph is 13. Other graphs could be constructed in which no solution would be possible with these constraints, such as a 4-clique. So even for this simple case, a large number of possible covers have to be considered. The number of possible local covers for a vertex of degree $\Delta$ is $\sum_{i=0}^\Delta \binom{\Delta}{i}$.

\subsection{Dependency Graph}
Given a Weighted Graph $G(V,E)$, a {\em Dependency Graph} $H(S,D)$ for $v \in V$ is defined by local solutions $s \in S$ and dependencies $d_{u,v} \in D$ between those solutions. In the case of the MWVC, each solution is made up of a set of vertices that cover the edges incident to $v$. The goal is to use the local solutions to build $\cC$, a vertex cover of $G$. The initial dependency graph for each vertex $v$ consists of the set containing the vertex $\{v\}$, and the set containing the neighbors of $v$, $\{n_v)\}$. 

\subsection{Prioritizing Local Solutions}

Given two local covers $c_1, c_2$, we define the degree of a cover ($w(c)$) as $\sum w(v)\:|\: v \in c, v \notin \cC$.  

\subsection{Negotiation Strategies}
Initially, each vertex $v$ is only aware of two solutions, the solution containing itself $s_s$ and the solution containing all of its neighbors $s_n$, which have no dependencies between them. In order to ensure 2-approximation, $v$ can only safely join $\cC$ if its own weight $w_v$ is at most half of the cumulative weight of all $w_u, u \in s_n $. If that condition cannot be met, then a vertex can join $\cC$ if it is the smallest node in it's local neighborhood not in $\cC$. A vertex that cannot meet either of these conditions waits for the next round. 

Some nodes will turn on, and in doing so will create new covers for their neighbors. At the beginning of each round, each vertex notes whether any vertexes in $s_n$ have joined $\cC$, and if so, it creates a new solution $s$ composed of itself and those vertexes. This solution will have a dependency to both $s_s$ and $s_n$, and the decision criteria can be applied to this new solution. 

\subsection{Partial Cover Dependency Graph}

The number of local covers increases as a function of the density of the local neighborhood. If $\Delta$ is small, this is not a problem, but as $\Delta$ increases the number of potential local covers increases rapidly. The Partial Cover Dependency Graph samples this exponential space and reduces the number of solutions to $\Delta$. A given vertex can only see two covers for it's own edges: the cover containing itself, and the cover containing all of its neighbors. The partial cover dependency graph samples the solution space based on what vertexes would have to be on if either of these two covers were off. 

\subsubsection{Construction of the PCDG}

Given a graph $G(V,E)$, for each vertex in $V$ we can define a partial cover dependency graph consisting of the {\em partial cover pair} $\cC_v, \cC_{n(v)}$ for v, and the partial cover pair for each neighbor of v. Given a node $v \in V$, $\cC_v$ consists of v and its two-hop neighbors, while $\cC_{n(v)}$ consists of $v$'s one-hop neighbors. For clarity, we define terms below.

\begin{defn}
One-hop Neighbor of $v$ : $u \in V \mid \exists e(u,v) \in E$
\end{defn}

\begin{defn}
Two-hop Neighbor of $v$ : $u \in V \mid \exists e(u,w) \in E \land \exists e(w,v) \in E \land \neg\exists e(u,v) \in E$
\end{defn}

\begin{defn}
$N_v$ : The set of one-hop neighbors of $v$
\end{defn}
\begin{defn}
$N_v^2$ : The set of two-hop neighbors of $v$
\end{defn}

\begin{defn}
$\cC_v$ : $\{v\} \cup N_v^2$
\end{defn}

\begin{defn}
$\cC_{n(v)}$ : $N_v$
\end{defn} 

\begin{defn}
Partial Cover Dependency Graph of $v$ : a graph $H(C,F)$ such that \begin{align*}& 1. C = \{\cC_v, \cC_{n(v)}\} \cup \{\cC_u, \cC_{n(u)}\} \forall u \in N_v\\ & 2. \exists f(c_1, c_2) \in F \iff \exists u \in V \mid u \in c_1 \land u \in c_2\end{align*}.
\end{defn} 

After constructing $H$, each cover is assigned a {\em weight} and a {\em degree}. The weight of a cover is defined as the sum of the weight of the vertexes in that cover, and the degree is defined by the number of edges for that cover. Figure~\ref{fig:pcdg} shows a graph and the corresponding partial cover dependency graph of a vertex in that graph.

\input{figs/fig-pcdg.tex}

\subsubsection{PCDG Algorithm}

\subsection{Redundancy Checking}

When vertexes make local decisions to join a cover in constant time, it is difficult to judge whether any neighbor will also decide to join the cover. In some cases, this leads to vertexes joining the cover which can be subsequently removed while still retaining full coverage. Removing these nodes will certainly reduce the total weight of the cover, and may also increase the potential lifetime of the network. We therefore implement a {\em redundancy checking} algorithm for Vertex Cover. Figure~\ref{fig:red} shows the progression of the algorithm.

\input{figs/fig-red.tex} 

\section{Experiments}
\label{sec:experiment}
Experiments were conducted to test algorithm performance and examine the relationship between maximizing network lifetime and minimizing vertex cover.
\subsection{Minimum Weighted Vertex Cover}
\label{sub:mwvc-exp}
Given the relationship between the target coverage and vertex cover problems, it is a reasonable hypothesis that a solution to the target coverage problem designed to maximize the lifetime of a network by reducing dependencies between covers would be a reasonable solution to the minimum weighted vertex cover. To test this hypothesis, Algorithm~\ref{alg:ldg} and Algorithm~\ref{alg:dgmm} were compared on a triangular grid.
\subsection{Experimental Design}
\label{sub:exp-design}
Random connected graphs were constructed, with the number of nodes and edges as the inputs. Nodes recieved a random weight between 100 and 1000.    

After a graph was formed, both algorithms were run on the graph and the weight of the cover output by each algorithm was recorded. The experiment was run repeatedly on graphs of 81 (9x9), 361 (19x19), and 1521(39*39) vertices. Results were averaged and can be seen in Table~\ref{tab:exp1r}.  

\subsection{Experimental Results}
\label{sub:exp-results}
\input{tabs/tab-exp1r.tex}
\section{Discussion}
\label{sec:discuss}
\bibliography{vertex_bib}
\end{document}